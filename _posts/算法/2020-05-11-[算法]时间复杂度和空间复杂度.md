---
title: "「算法」时间复杂度和空间复杂度"
subtitle: ""
layout: post
author: "afsun"
header-style: text
tags:
  - 算法
---
# 时间复杂度和空间复杂度

- 时间复杂度: 执行当前算法消耗的时间
- 空间复杂度: 执行当前算法占用的内存空间

## 时间复杂度

时间复杂度一般是首要考虑的,因为在现代计算机的内存越来越大,且内存也越来越便宜.所以时间允许速度的优先级更高.

公式为: *T(n) = O(f(n))*  f(n)表示每行代码的执行次数之合,O表示正比例关系:，大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

### 常数阶O(1)

```java
int i = 1;
int j = 2;
i = i + j;
```

上述代码在执行时,消耗的时间并不会随着某个变量增长而增长.一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。



### 对数阶O(LogN)

```java
int i = 1; 
while(i < n){
    i = i*2;
}
```

2^T = n -> T = log2N 所以此段代码的循环次数是随着n的对数阶成相关的

> Log(2,n)和Log(10,n)增长率应该相等,因为有对数的换底公式,当N趋向无穷大时,两者近似相等



### 线性阶O(n)

```java
int[] numList = {1,2,3,4,5}
fot(int i=0;i<numList.length();i++){
    logger.info(numList[i]);
}
```

上述的**numList**的大小为5,若是大小变成n时,那么循环中的代码就会循环N次,所以他的时间复杂度是随着n的变化而变化的.



### O(nLogN)

```java
for(int i = 0;i < n :i++){
    int j = 1;
    while(j < n){
    i = i*2;
	}
}
```

将LogN时间复杂度的代码放入到线性时间复杂度的循环中那么时间复杂度就变成了两者的相乘



### 平方阶 O(N^2)

```java
for(int i = 0;i < n:i++){
    for(int j = 0;j < n;j++){
        // todo
    {
}
```



### 指数阶O(k^n)

```java
int fib(int n){
    if(n<=2) return n;
    return fib(n-1) + fib(n-2);
}
```

> 斐波那契的递归求解方式的调用其实就是一个完全二叉树,当深度为n时,结点总数为2^n-1个,所以他是指数阶的时间复杂度

采用递归的这种方式求斐波那契时会存在重复求值的情况:![1589166938351](http://tuchuansun.oss-cn-hangzhou.aliyuncs.com/typora/202005/11/111539-732293.png)

如f(6)时,计算了3此f(4),可以通过缓存优化的方式减少运算次数,也就是用空间复杂度的方式换时间复杂度.

## 空间复杂度

算法在运行过程中临时占用的存储空间的度量

### 常数阶O(1)

```java
for (k = 0; k < j; k++){
    x++;
}

for (i = 0; i < n; i++){
    for (j = 0; j < i; j++){
        for (k = 0; k < j; k++){
            x++;
        }
    }
}

```

不管外层的循环有多少层,空间的复杂度没有改变,都是共享一个x的内存空间



### 线性阶O(n)

```java
int fac(int n){
    if(n <= 2){
        return n;
    }else{
        return fac(n-1)*n;
    }
}
```

采用递归的方式求阶乘时,时间复杂度为O(n),空间复杂度也为O(n),因为在递归时,其实就是内存中的压栈和出栈,所以都程线性关系.



## 常用的时空复杂度

![1589167123031](http://tuchuansun.oss-cn-hangzhou.aliyuncs.com/typora/202005/11/111845-160266.png)

