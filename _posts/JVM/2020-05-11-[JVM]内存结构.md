---
title: "「JVM」内存结构"
subtitle: ""
layout: post
author: "afsun"
header-style: text
tags:
  - JVM
---
# JVM内存结构

[](https://blog.csdn.net/mine_song/article/details/71517200)

![JVM%20d16fcb4f1ff14024a217921beff20aeb/Untitled.png](http://tuchuansun.oss-cn-hangzhou.aliyuncs.com/typora/202005/11/095225-426908.png)

# 线程私有区域

## PC计数器

- 记录当前线程执行的字节码行号，字节码解释器通过计数器的值来实现跳转，循环，判断

## 本地方法区

- 提供本地的方法，类似于Thread.Sleep()方法就是调用本地的方法

## 栈和栈帧

- 栈是用来存储方法执行的栈的栈帧

![JVM%20d16fcb4f1ff14024a217921beff20aeb/Untitled%201.png](http://tuchuansun.oss-cn-hangzhou.aliyuncs.com/typora/202005/11/095228-545767.png)

方法的执行就是栈帧的压入（PUSH），方法执行完毕栈帧会自动销毁，这个时候会弹出栈帧（POLL），**栈中的内存空间是不由GC来管理的**。

### 局部变量区

该区域存储的是方法中的临时变量，即在方法中定义的变量，生命周期也是跟方法执行的生命周期一致。类似于

```java
public void fun(){
	int temp = 1;
}
```

这个`temp`变量就是局部变量，保存在局部变量区中的

### 操作数栈

也是一个先入后出的栈结构，通过栈结构完成算数运算或者是调用其他方法都是在操作数栈中完成的

### 动态链接

运行时常量池中保存了大量的符号引用，这些符号引用可以看成是方法的间接引用，列如方法A想要调用方法B，那么A方法就会调用B方法的符号引用，但是符号引用没有具体的内存地址，所以需要将符号引用转换成直接引用。如果是在类加载阶段将符号引用转换成直接引用那称为**静态解析**，如果在运行时转换那就是**动态链接**。

在JVM加载类文件的时候，如果调用的方法在编译时可知且在运行期间不会变化那么会自动转换为静态解析，否则就保留他的动态性，java中的多态，重写就是利用这样的特性实现的。可以在方法上加上`final`，`static`,`private`修饰符，那么方法就是静态绑定的

### 方法返回值

无论当前方法的调用结果是正常还是异常，都需要在执行完成之后返回到之前被调用的位置上，那么这个时候当前栈帧就承担着恢复调用者状态的责任。之前曾经提及过，在方法内部调用了另外一个方法时，将会有一个与当前方法相对应的新栈帧被创建出来，当方法调用完成之后，当前栈帧随之被丢弃，前一个栈帧又重新变为了当前栈帧，而被调用的方法如果带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。

# 线程共享区域

## 堆(GC回收频繁和考虑吞吐量大的地方)

**在jdk8中将静态变量放在了堆中,字符串常量池也在堆内存上**

所有对象的创建都在堆上，OutOfMemoryError异常也是由于堆内存溢出。

![JVM%20d16fcb4f1ff14024a217921beff20aeb/Untitled%202.png](http://tuchuansun.oss-cn-hangzhou.aliyuncs.com/typora/202005/11/095230-338334.png)

将内存平均分成A、B两块，算法过程：

1. 新生对象被分配到A块中未使用的内存当中。当A块的内存用完了， 把A块的存活对象对象复制到B块。
2. 清理A块所有对象。
3. 新生对象被分配的B块中未使用的内存当中。当B块的内存用完了， 把B块的存活对象对象复制到A块。
4. 清理B块所有对象。
5. goto 1。

优点：简单高效。缺点：内存代价高，有效内存为占用内存的一半。

![JVM%20d16fcb4f1ff14024a217921beff20aeb/Untitled%203.png](http://tuchuansun.oss-cn-hangzhou.aliyuncs.com/typora/202005/11/095231-223598.png)

### 新生代

- MinorGC回收管理的区域,一般存放生命周期比较短的对象

Eden区：对象创建所在的区域（大对象创建会在老年代），当Eden区内存不足时会出发MinorGC对新生代进行垃圾回收

ServivorTo：保留MinorGC的幸存者

ServivorFrom：上次MinorGC的幸存者，作为这次扫描的目标

**MinorGC**：

1. 将Eden区和S0作为回收区,将未被回收的内容放入到S1中
2. 若Eden区再满后,将Eden+S1作为回收区,将未被回收的对象放入S0中
3. 每次幸存的对象都会在**年龄**上加一,直达年龄到达某个阈值,会将对象放入到**老年代**中.

### 老年代

- 结果多次的回收,仍存活的对象将放入到老年代中,此对象具有较长的生命周期,通过FullGC可以才可以回收此区域中的对象

**FullGC**

触发条件

- 老年代被写满
- System.gc()方法被调用时,此方法只是建议回收
- MinorGC时,Eden+S0→S1复制时,对象过大会将对象直接放入到老年代中,此时可能触发FullGC

**标记-整理算法**

而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如下图所示

![JVM%20d16fcb4f1ff14024a217921beff20aeb/Untitled%204.png](http://tuchuansun.oss-cn-hangzhou.aliyuncs.com/typora/202005/11/095232-100916.png)

## 方法区

[](https://blog.csdn.net/a1214624851/article/details/83016600)

用来存放class的所有信息(类名,方法信息,字段信息),静态变量,常量已及编译后的代码

### 运行时常量池

hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)

**JDK1.8 变动**

将永久代去除,将永久代中类的信息放入到**元空间**中(**类的信息,静态变量,其他常量,编译后的class文件**),将**字符串常量池**转移到堆中

- 将永久代中的运行时常量池中的字符串常量池放入到堆中
- 将运行时常量池中的类信息和类变量放入到元空间中
- 永久代中类编译后的文件放入元空间中

# 常量池

## 字符串常量池(堆中)

逻辑上属于运行时常量池

数据结构类似于一个HASH表,默认长度为1009.只会存放引用

用来存放堆内字符串的引用

```java
String s1 = "hello,world!";
String s2 = "hello,world!";
```

执行完第一句代码,常量池就已经存在字符串"hello,world!",s2时并不会再次开辟内存放入字符串而是直接引用s1的内存地址

## CLASS文件常量池

- 类文件在编译后会生成一个class文件;class文件中包含了类的字段,方法,接口等描述信息.还有一项信息就是常量池

类常量池存放两大类常量,**字面量**和**符号引用**

字面量: 八种基本数据类型,字符串文本,`final`修饰的常量

符号引用: 类和方法的全限定名,字段名称和描述符,方法的名称和描述符

## 运行时常量池概念

JVM在加载类时,会经过:加载,连接,初始化,而连接又包含了验证,准备,解析三个阶段.类加载到内存中后,JVM会将class中的常量池放入到运行时常量池中,每个类都有一个运行时常量池,在解析的时候会将符号引用转换成直接引用,解析的过程就是查询字符串常量池,保证运行时常量池引用的字符串和常量池是一致的..运行时常量池具有动态性.运行时也可将常量加入到运行时常量池中,如String的intern()方法.