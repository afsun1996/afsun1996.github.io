---
title: "「分布式」分布式事务"
layout: post
author: "afsun"
header-style: text
tags:
 - 分布式
 - 分布式事务
---

# 分布式事务

传统的单体服务的事务比较简单，满足ACID就可以了，即：原子性，一致性，隔离性，持久性。而在分布式微服务上事务却比较难实现，这是因为事务的操作不是在同一个服务上进行的了，可能是多个服务参与了同一个事务，这个时候事务就比较困难，

## 刚性事务

刚性事务最常见的就是数据库事务，事务满足ACID。即系统中的状态如果成功则都成功，如果失败都失败，不存在中间状态。



### WAL技术



### 两步提交

![image-20200809180422395](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200809180422395.png)![img](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/524341-20160718200514638-1914892480.png)

#### 第一阶段：准备阶段

1. 协调者发起并发送事务请求给各个参与者，询问是否可以发起事务
2. 参与者执行事务并保存修改日志，暂不提交
3. 参与者执行成功返回Y，执行失败返回N

#### 第二阶段：提交阶段

+ 所有参与者都返回Y时，协调器发送所有指令让事务提交
  + 参与者节点向协调者节点发送提交完成消息
  + 协调者节点受到所有参与者节点反馈的提交完成消息后，完成事务
+ 有一个参与者返回N时，协调器发送回滚指令，让所有参与者回滚
  + 参与者节点利用之前写入的undo信息执行回滚，并释放在整个事务期间内占用的资源
  + 参与者节点向协调者发送回滚完成消息
  + 协调者节点收到所有参与者节点反馈的回滚完成消息后，取消事务

#### 缺陷

1. 同步阻塞，所有参与事务的线程都会被阻塞，等待提交或者回滚
2. 单点问题，协调者网络故障则导致事务一直被锁
3. 脑裂问题，提交阶段可能存在某些参与者提交失败的情况

### 三步提交

![image-20200809181042673](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200809181042673.png)![img](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/524341-20160718200527138-807062442.png)

> 和两步提交不同的是，三步提交将过程分为了三步：

#### 第一阶段:CanCommit

1. 协调者向参与者发送一个包含事务内容的 canCommit 请求，询问是否可以执行事务提交操作，并等待响应
2. 参与者发送响应给协调者

#### 第二阶段:PreCommit

1. 执行事务的处理,将操作日志记录下（undoLog和redoLog）,锁定资源。不提交
2. 参与者向协调器发送ACK响应,并等待回应

#### 第三阶段:DoCommit

1. 若所有参与者都为Y,则提交所有事务并返回ACK给协调者
2. 协调者收到所有的ACK则完成此次事务，并释放资源的锁
3. 参与者成功完成事务会向协调器发送ack
4. 协调器接受到所有的ack会完成事务

#### 优化的地方

1. 协调器和参与者都有超时机制，在2PC中只有协调器有超时机制（如果在一定时间没有接受到参与者的响应就是超时）
2. 降低同步阻塞。在3PC中，第一阶段并没有让参与者直接执行事务，而是在第二阶段才会让参与者进行事务的执行。大大降低了阻塞的概率和时长。并且，在3PC中，如果参与者未收到协调者的消息，那么他会在等待一段时间后自动执行事务的commit，而不是一直阻塞。
3. 2PC中有一种情况会导致数据不一致，如在2PC的阶段二中，当协调者向参与者发送commit请求之后，发生了网络异常，只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。这种情况在3PC的场景中得到了很好的解决，因为在3PC中，如果参与者没有收到协调者的消息时，他不会一直阻塞，过一段时间之后，他会自动执行事务。这就解决了那种协调者发出commit之后。
4. 协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。这种情况在3PC中是有办法解决的，因为在3PC中，选出新的协调者之后，他可以咨询所有参与者的状态，如果有某一个处于commit状态或者prepare-commit状态，那么他就可以通知所有参与者执行commit，否则就通知大家rollback。因为3PC的第三阶段一旦有机器执行了commit，那必然第一阶段大家都是同意commit的，所以可以放心执行commit。

**https://www.sohu.com/a/369350086_115128**

#### 3PC无法解决的问题

在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。目前最优美的解法就是**Paxos**算法。

### Paxos算法



## 柔性事务



### TCC补偿事务

### 最大努力尝试