---
title: "OSTEP笔记1-内存虚拟化"
subtitle: ""
layout: post
author: "afsun"
header-style: text
tags:
  - 操作系统	
  - 读书笔记
---
# OSTEP-内存虚拟化

## 地址转换

> 在一开始的时候，程序是跑在裸机上的。也就是程序操作的是真实的地址。这样带来了很多的局限性，比如两个进程可能互相被干扰，需要开辟一整块连续的内存空间。通过地址基址寄存器和偏移量的值相加就能得到真实的内存地址

​	CPU在执行每条指令的时候，都需要从虚拟地址转换成物理地址，这个可能通过MMU实现。实际上是通过两个寄存器：基址寄存器和界限寄存器来实现。

基址寄存器来存放该进程映射到物理内存上的基础地址，界限寄存器是用来判断进程操作内存是否越界，如果有越界则会抛出硬件中断/异常

![image-20200610145248572](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200610145248572.png)

进程中的虚拟内存如上图所示

在图中，操作系统占有最开始的16K地址区域，代码实际上是放在了32K~48K这个地址区间的，所以需要在程序的虚拟地址上加上32K的基础地址。

物理地市 = 基地址 + 虚拟地址

### 硬件提供的功能

1. CPU提供**特权模式**和**用户模式**，形成保护机制，用户进程无法执行一些特权指令，当执行特权指令时必须陷入操作系统，让操作系统去执行。
2. 基址寄存器和边界寄存器，在地址翻译时需要用到。边界寄存器是防止代码的访问超过地址边界，分支进程访问到其他进程的数据。

### 操作系统提供功能

1. 对内存的管理，分配新内存；回收内存
2. 切换进程时可更新基址寄存器和边界寄存器中的值（上下文切换）
3. 收到硬件的异常可以对异常进行处理（如：缺页异常时，操作系统回去硬件中读取相应的页数据）

## 分段

> 虽然引用地址转换能减轻编码时的负担（不用记忆实际内存地址），但是对于内存使用确实很浪费的，而且如果程序的地址空间大于内存的地址空间该程序是不能运行的，仅仅使用地址转换是有局限性的。

增加基址寄存器和界限寄存器的数量，将地址空间分成一段一段的，每一段都是连续的地址。

![image-20200622093345780](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200622093345780.png)![image-20200622093433215](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200622093433215.png)

​	在图中，只有使用的内存被分配了物理内存，其他空闲的内存可以分配给其他程序使用。

​	在请求某个虚拟地址的时候，根据地址中的高位bit或者是硬件来判断访问的是哪个代码端，然后通过基址寄存器加上偏移量的方式计算出实际地址，再通过边界寄存器判断是否越界，如果越界则抛出异常让操作系统处理。

>  如何判断地址对应段？
>
> ​	通过地址高位的bit标明段，或者判断地址是从什么硬件过来的，如果是PC则访问的肯定是代码段，如果是栈指令肯定是访问栈段，其他的就是访问堆了。

### 还存在的问题

​	物理空间很快就充满了很多内存碎片，这些内存碎片分布散乱无法连续起来用。如左图所示

![image-20200622095556527](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200622095556527.png)                           

可以通过重新排列现有的段来压缩物理内存，停止正在运行的程序，将他的数据移动到一个连续的区域，但是这样的代价却是很高的。

## 空闲内存管理

​	如果将内存分为固定大小单元通过一个链表结构来记录下空闲的单元，那么会导致一个问题——碎片化。当请求一个较大的内存空间时，无法找到连续的空间。

![preview](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/v2-fc2d4f30e7fb3ff7ba893485e5ba5334_r.jpg)如图所示，如果要请求20byte的空间大小就会失败，实际上空间是足够的。

### 分裂与合并

> 一个空闲列表包括堆中的空闲元素集合，就是下面这个30byet的堆
>
> ![image-20200623112132538](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623112132538.png)

内部数据如图所示：![image-20200623112216644](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623112216644.png)

当请求的空间大小大于10byte时就会报错，因为两个10byte的空间不是连续的，无法分配出去。如果请求的空间大小小于10byte时就会分裂成两个空间一个是已经分配的空间一个是未分配的空间。![image-20200623113059126](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623113059126.png)

如果将分配的10byte数据和1byte数据释放掉，内存管理会将其合并

![image-20200623113212188](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623113212188.png)![image-20200623113250940](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623113250940.png)

### 最优分配

在空闲链表中找到最接近需求大小的内存块进行分配，但是带来了一个O(n)的时间复杂度，因为需要将所有的空闲块进行遍历才能得出这个结果

### 最坏分配

和最优分配相反的一种方式，分配最大的空闲块进行分配

### 首次适合分配

找到第一个合适的空间大小就分配

## 分页

> 分段是分配动态大小的内存，但是这种方式随着时间的推移会产生内存的碎片化，并且对于稀疏的大内存需求的地址空间无法支持。那动态大小的内存分配不适合管理，我们就会想到按照固定大小来进行内存分配，这就是分页。分页会将内存按照一个固定的大小分为一个一个的部分。这些固定大小的部分我们称为页（page）。

![image-20200623114638707](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623114638707.png)

如图所示，将64byte的物理空间分为8个页，操作系统通常会为每个进程保留一个称为页表（page table）的数据结构。页表的主要作用是存储地址空间中每个虚拟页的地址转换（address translations），从而让我们知道每个页面在物理内存中的位置。

列如：VP0 -> PF3 VP2->PF5

### 如何翻译为物理地址

首先将虚拟地址分成两个部分：虚拟页码(VPN)和页面内的偏移量。对于本例，由于进程的虚拟地址空间为64字节，因此我们的虚拟地址需要6位。因此，我们的虚拟地址可以概念化如下：

![image-20200623115754869](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623115754869.png)![image-20200623115640193](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623115640193.png)

前两位标识虚拟地址的页号，后面是偏移地址

MOV 21,%eax

21的2进制=010101所以他的页号=01 虚拟页块号也成为**VPN**(Vitual Page Number)

再通过页表(PT)结构找到对应的页表条目(PTE),根据页表条目找到虚拟页号对应的物理基地址，然后加上偏移量计算出实际地址。

### PTE中会存放那些信息

![image-20200623145636149](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623145636149.png)

+ PFN 物理地址
+ Valid 有效标志位。如果区域未使用到就是无效的区域，进程访问到该区域会陷入异常
+ project 保护位 指示是否可读，写入或者执行
+ present 存在位 指示此页面是再内存上还是磁盘上（可能被swap）

## 更小的页表

> 分页仍然具有一些问题，比如每次取值都需要去转换，且PE表的大小太大放在内存中占用了太多空间。所以采用分页加分段的方式来管理内存

在每个逻辑段上创建一个页表。基址寄存器记录该段的页表的物理地址，界限寄存器记录页表的尾页。地址空间分为3段：代码段，堆段，栈段.

![image-20200623151355568](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200623151355568.png)

通过seg来找到对应的基址寄存器，根据VPN的页号找到页表中对应的PTE地址最后加上偏移地址就是物理地址了。

但是这样做还是会有大量的页表浪费。

可以通过二级页表的方式实现，其实也就是以时间换空间的做法，因为页表的存储结构是一个连续的内存区域，现在将页表分成两级第一级的地址是连续的，第二级和第一级直接互相关联，在第二级页表上可以找到对应的内存地址