---
title: "OSTEP笔记1-CPU虚拟化"
subtitle: ""
layout: post
author: "afsun"
header-style: text
tags:
  - 操作系统	
  - 读书笔记
---
# OSTEP-CPU虚拟化

​	CPU是通过虚拟化来实现多个任务*同时*进行的,通过时间片的切分方式来完成不同的进程同时发生,实际上由于进程切换的时间间隔较短所以看起来像是同时在发生一样.需要实现这样的并发,操作系统需要一个低的机械原理(low-level machinery mechanisms  )和一个高的策略(policies)

## 进程概述

> 在计算机操作系统中运行的程序都是进程。
>
>  内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，cpu堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，cpu堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。

进程的重要组成:

+ 内存空间 操作指令存放于内存中,正在运行程序读取和写入的数据也在内存中,进程可以寻址的内存空间也是进程的一部分
+ PC 程序计数器
+ SP 栈指针 (栈顶指针)
+ FP 帧指针 (栈底指针)

### 进程控制块PCB

> 又称进程描述符，进程属性.每个进程都对应一个PCB
>
> 存放在内核空间中

#### PCB进程内容

1. 进程标识符信息：进程id，父进程id...
2. 处理机状态：CPU寄存器中的状态
3. 进程调度信息：进程状态，进程优先级，，
4. 进程控制信息：代码的内存开始地址，磁盘上的位置，资源清单

### 进程内存空间

![image-20200607095638765](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200607095638765.png)

>  每个进程都有一个自己的内存空间，在这个内存空间中由内存空间的最低位作为基址映射到物理内存中。
>
> 每个进程的内存空间由用户空间和内核空间组成，用户空间是作为多任务运行的沙盒的作用，在操作系统调度时提供其偏移量让cpu在这个堆栈上执行代码，而内核空间是连续的，所有进程的内核空间映射到同一物理内存地址。

![img](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/20140904215816750)



### 程序运行过程

每次函数的调用都会在进程调用栈上维护一个独立的栈帧,栈帧一般包括:

1. 函数的返回地址和参数
2. 临时变量
3. 函数调用上下文

![image-20200605110540664](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200605110540664.png)

调用者需要知道被调用者的返回值,被调用者需要知道传入参数和返回的地址.函数调用过程如下:

1. 参数入栈
2. 返回地址入栈
3. 栈帧调整 
   1. 将调用者的FP压栈，保存指向调用者FP的地址
   2. 将当前栈帧切换到新栈帧
   3. 将参数入栈,当前函数的下个指令地址压入栈中
4. 代码跳转到新函数的入口
5. 将返回值保存在寄存器（EAX）中
6. 恢复SP,回收空间局部变量空间
7. 将上个栈帧的底部恢复到FP位置
8. 弹出栈顶元素,跳转到返回地址

> 所以程序的运行就是栈帧的压栈和出栈的操作

### 进程的运行状态

+ Running 进程正在运行中
+ Ready 就绪状态,等待OS分配时间片
+ Blokced 阻塞状态  进程在执行IO等非CPU操作

![image-20200605141138613](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200605141138613.png)

## 进程的系统API

### fork()

fork()操作用来创建一个新的进程

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/wait.h>

int main ( int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
    } else { // parent goes down this path (main)
        int rc_wait = wait(NULL);
        printf("hello, I am parent of %d (rc_wait:%d) (pid:%d)\n",
               rc, rc_wait, (int) getpid());
    }
    return 0;
}
```

语句在调用` rc = fork` 后会返回两次,两个进程的代码一样,将要执行的代码都是 if(rc < 0),但是父子进程的rc值是不一样的,在父进程中返回值是子进程的PID,而在子进程中返回是0,如果fork失败则会返回负数.

### wait()

一般用于父线程中等待回收子进程的资源

当一个进程正常或者异常终止时,OS内核回向该进程的父进程发送一个信号

对于这种现象,父进程是默认忽略的.而调用wait()方法后则会进入判断,如果有子进程终止则立马返回

所以上述的代码返回一定是:

```shell
hello world (pid:29266)
hello, I am child (pid:29267)
hello, I am parent of 29267 (rc_wait:29267) (pid:29266)
```

### exec()

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<sys/wait.h >
int main ( int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
        char *myargs[3];
        myargs[0] = strdup("wc"); // program: "wc" (word count)
        myargs[1] = strdup("p3.c"); // argument: file to count
        myargs[2] = NULL; // marks end of array
        execvp(myargs[0], myargs); // runs word count
        printf("this shouldn’t print out");
    } else { // parent goes down this path (main)
        int rc_wait = wait(NULL);
        printf("hello, I am parent of %d (rc_wait:%d) (pid:%d)\n",
               rc, rc_wait, (int) getpid());
    }
    return 0;
}
```

exec()可以在进程中调用另一个程序，在上述代码中通过execvo调用了wc命令，计算了p3.c的代码行数

```
hello world (pid:29383)
hello, I am child (pid:29384)
29 107 1030 p3.c
hello, I am parent of 29384 (rc_wait:29384) (pid:29383)
```

​	运行excec()时，首先重新初始化堆栈和一些其他的内存空间，接着OS开始通过给定的参数来运行。他并不会创建一个新的进程，而是将当前的进程来替代。当exce()执行成功后会直接返回进程关闭。

### 三个命令的协同使用

`wc p3.c > newfile.txt `

这个命令的用处是将p3.c的函数获取到并重定向到newfile.txt文件中，如何做到的呢？

首先shell先fork一个子进程，在进程中先关闭标准输出流，然后打开newfile.txt。之后调用exec()调用wc p3.c的操作，最后linux将输出结果定向到了文件流中

> ps: linux中 标准输入流为1 标准输出流为2 异常流3 ，linux从0开始寻找可以使用的文件描述符，在这个例子中newfile是第一个可用的文件描述符

## 陷入内核

> 为了虚拟化CPU，操作系统会以某种方式让各个任务来共享CPU，那么OS如何获得CPU的控制权，这就需要有陷入内核的机制

最简单的方式就是，在操作系统中运行一个进程时，先是在进程列表创建条目，然后分配内存，再然后设置栈帧，清楚寄存器执行main最后运行结束返回到操作系统中，但是这样的方式并不安全，无法控制进程的操作，如果进程去做一些敏感的操作,OS无法去干预，于是引入了两种模式： 

+ 用户模式：在用户模式下运行代码会受到限制，进程不能直接发起IO请求这样做CPU会触发异常终止代码运行
+ 内核模式：拥有最大的权限，可以做任何事情

通过操作系统提供的一些陷阱接口，用户模式下的应用程序通过调用这些陷阱接口来完成一些敏感的操作比如IO读取，在陷入内核前，会将当前用户模式进程下的寄存器状态保存在进程的内核栈中，并去运行内核模式下的操作。

> 在C语言中调用Open()或者Malloc()指令其实在底层的C库中还是用汇编去调用了陷阱指令和对应的陷阱号，这样CPU就会触发一次软中断，并在CPU上的陷阱表找到对应内核执行的入库地址。而这些陷阱表是在内核启动的时候写入的

### 陷入内核的步骤

1. 初始化陷阱表

2. 在内核模式下

   1. 在进程列表上创建进程条目
   2. 为进程分配内存
   3. 程序从磁盘加载到内存
   4. 根据入参和.....来设置进程栈
   5. 将寄存器，pc等值压如内核栈中

3. 硬件

   1. 从内核栈恢复寄存器
   2. 转向用户模式

4. 应用模式：

   1. 运行main
   2. 执行系统调用
   3. 陷入内核

5. 硬件：

   1. 将寄存器保存到内核栈中
   2. 跳转到陷阱表中的内核上的陷阱处理程序

6. 内核：

   1. 处理陷阱
   2. 做系统调用工作
   3. 返回

7. 硬件

   1. 从内核栈恢复寄存器
   2. 转向用户模式
   3. 跳转到陷阱之后的程序计数器

   从内核模式切换到用户模式的时候，需要将内核栈出栈然后恢复到用户栈。

   内用户模式陷入内核模式则，需要首先将用户堆栈地址压入到内核栈，还有用户栈的一些信息。

   > 遇到陷阱指令是进入内核的一种方式，但是这不是唯一的一条方式，在CPU中会有一个时钟中断的概念，每个时钟中断都会让内核重新获得CPU控制权。

### 保存和恢复上下文

所谓的上下文切换，就是操作系统需要保存正在执行的进程中的一些寄存器的值，并为即将执行的进程恢复寄存器的值（从他的内核栈）

下图是上下文切换实例：

![image-20200605214704228](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200605214704228.png)

1. 在启动时,开启了时钟中断并在中断向量表中设置了处理函数的偏移量
2. 进程A在运行过程中遭遇到了时钟中断，进入到了cpu中断处理中
3. 首先保存PC寄存器的值到内核站中，然后硬件切换堆栈指针到内核栈中，完成用户态到内核态的切换
4. 内核态中首先运行调度程序判断是否需要切换任务，如果需要切换则保存寄存器中的值到A的进程结构中去；再将B的进程结构中的上下文部分恢复到寄存器中，指针指向B进程内核栈的位置，从陷阱返回
5. 硬件从内核栈出栈，获得B进程进入中断前压入的PC地址，将PC地址恢复到PC寄存器中 切换指针到用户态
6. 执行B进程

## 进程调度

> 操作系统除了在应用进程调用陷阱指令而进入内核态之外，CPU还有一个时钟中断，在时钟中断时会从用户态转换成内核态并让进程运行调度程序选择下个时间片运行的进程。

### 以平均运行周期来考量

> 从任务的完成时间出发，在非交互性的计算机中，完成任务的周期时间是一个很重要的考量。
>
> $ T_{turnaroud} = T_{completion} - T_{arrival} $

#### 先进先出(FIFO)

采用先进先出队列的结构实现，假设任务一同到来先入队的进程先运行

![image-20200608090935140](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608090935140.png)

这样的处理方式有个问题，但重计算的任务先到达，那么就会先计算重任务，从而让平均计算周期变长

![image-20200608091218006](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608091218006.png)

前者的$ T_{avg1} = \frac{10 + 20 +30}{3} = 20s $                                     后者图中的$  T_{avg2} = \frac{100 + 110 + 120}{3} = 110s $

遇到这样的情况那么先进先出的结构就不能解决了，所以引入下面的调度方法

#### 最短任务优先(SJF)

最短任务优先是在每次调度的时候，将需要执行的任务排序，先执行占用cpu时间短的吼执行占用时间长的

![image-20200608092020639](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608092020639.png)

目前的平均时间 = $ \frac{10+20+120}{3} = 50 $,相对于FIFO来说降低了50%的平均计算时间，但是这样只能解决任务的开始于同一时间，如果像下图一样任务执行的时间不一定那么SJF就不能起到作用：

![image-20200608092312001](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608092312001.png)

#### 最短完成时间优先(STCF)

该机制可以在CPU的时钟中断中进行判断进程表中的下个就绪进程的可能完成时间，来进行抢断。将完成时间短的任务放在前面运行。

![image-20200608092846830](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608092846830.png)

### 以响应时间来考量

> 现在的计算机都是交互式的，热门操作终端来与计算机操作系统交互。如果不考虑任务的响应时间那么体验是非常糟糕的，比如输入了一个字符串却要等其他进程运行完成以后在shell上才显示出来。
>
> 将响应时间定义如下：$ T_{response} = T_{firstrun} - T_{arrival} $

#### 时间片轮训法（RR）

​	以上两个调度方法：SJF和STCF都是针对于进程运行时间来设定的，当ABC三个调度任务的运行时间一致的时候，不管是SJF还是抢占式的STCF都是按照顺序运行的，这在任务执行时间来看是没有什么问题的，但在响应时间的角度来看是非常糟糕的。

​	为了解决这样的情况，采用了**Round_Robin**调度算法，RR算法在时间上对CPU进行切片。每次的时间片都会切换上下文选择一个进程去执行，一直这样重复知道这个进程被执行完成。

![image-20200608095215143](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608095215143.png)

如上图所示：将时间片设置为1.那么通过时间片切换的方式来看响应周期为$\frac{0+1+2}{3} = 1$

通过最短任务优先算法来看响应周期为$\frac{0+5+10}{3} = 5$

> 时间片轮训算法上时间片的周期选择很重要，如果时间片的周期选择的过大那么响应周期就会变大。如果时间片的时间设置的过小则会频繁的进行上下文的切换影响cpu运行的效率

**需要考虑到IO操作的影响**：

当IO操作的时候，在当前进程中CPU就会等待IO操作的返回所以这段时间CPU是在空闲的。所以调度算法可以将运行IO操作的进程设置为阻塞态，让当前的CPU去运行其他的进程，当IO操作返回的时候再将该进程设置为就绪态，等待时间片的轮训。![image-20200608100450515](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608100450515.png)

### 多级反馈队列（MLFQ）

> 既考虑到**最短任务优先算法**和**最短完成时间优先算法**一样考虑到任务完成时间$T_{around}$，又考虑到最短响应时间这就是多级反馈队列的优势。
>
> 多级队列具有多个不同的队列，不同的队列具有不同的优先级。

#### 基础准则

+ 如果A优先级大于B，则A运行

+ 如果A优先级等于B，则A和B进行RR（时间片轮训）

+ 当任务进入队列的时候首先会放在优先级最高的队列

+ 如果在当前队列时间片结束时仍未结束则将优先级降低，放入下一级队列中。只要用完时间片的配偶就自动降低优先级

+ 经过一段时间将所有的任务都重新放入最高优先级队列中

  ![image-20200608203932286](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608203932286.png)
  
  

> 在实际的操作系统中，可能有60多层的队列，每个队列的时间份额从几十毫秒到几百毫秒都有。这是为了细粒化的筛选出任务的优先级

### 比例份额

> 称之为公平额调度程序，比例份额算法基于在最终所有的程序都获得一定比例的CPU时间。
>
> 将彩票中奖比作调度任务选中了进程获得cpu的时间片，将进程的资源比重比作拥有的彩票个数；当进程A拥有75张彩票，进程B拥有25张彩票。那么按照概率来看进程A有75%的概率获得CPU的时间片。而运行的时间越长这个概率会越准确最终无限趋向于75%。

#### 彩票算法实现

![image-20200608204928692](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608204928692.png)

实现起来非常简单，该队列中又三个进程。进程的资源数加起来是400.那么久在0~400中随机生成一个数字。看数字是落在哪个区间的。去唤醒区间对应的进程。

#### 步长算法

>  系统中每个工作都有一个步长，该值和票数成反比。用一个大数处于这些票数就是步长，利用一个行程表记录所有进程运行的里程；每次运行里程最短的进程。

![image-20200608205556808](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200608205556808.png)

缺点：需要有一个全局结构来保存进程的状态。比例份额的算法在调度中用的很少，因为进程的彩票数很难去确定下来。