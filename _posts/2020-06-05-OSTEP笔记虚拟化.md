---
title: "OSTEP笔记1-虚拟化"
subtitle: ""
layout: post
author: "afsun"
header-style: text
tags:
  - 操作系统
---
# OSTEP-虚拟化

​	CPU是通过虚拟化来实现多个任务*同时*进行的,通过时间片的切分方式来完成不同的进程同时发生,实际上由于进程切换的时间间隔较短所以看起来像是同时在发生一样.需要实现这样的并发,操作系统需要一个低的机械原理(low-level machinery mechanisms  )和一个高的策略(policies)

	## 进程

> 在计算机操作系统中运行的程序都是进程

进程的重要组成:

+ 内存空间 操作指令存放于内存中,正在运行程序读取和写入的数据也在内存中,进程可以寻址的内存空间也是进程的一部分
+ PC 程序计数器
+ SP 栈指针 (栈顶指针)
+ FP 帧指针 (栈底指针)

### 程序运行过程

每次函数的调用都会在调用栈上维护一个独立的栈帧,栈帧一般包括:

1. 函数的返回地址和参数
2. 临时变量
3. 函数调用上下文

![image-20200605110540664](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200605110540664.png)

调用者需要知道被调用者的返回值,被调用者需要知道传入参数和返回的地址.函数调用过程如下:

1. 参数入栈
2. 返回地址入栈
3. 栈帧调整 
   1. 将调用者的FP压栈，保存指向调用者FP的地址
   2. 将当前栈帧切换到新栈帧
   3. 将参数入栈,返回值入栈
4. 代码跳转到新函数的入口
5. 将返回值保存在寄存器中
6. 恢复SP,回收空间局部变量空间
7. 将上个栈帧的底部恢复到FP位置
8. 弹出栈顶元素,跳转到返回地址

> 所以程序的运行就是栈帧的压栈和出栈的操作

### 进程的运行状态

+ Running 进程正在运行中
+ Ready 就绪状态,等待OS分配时间片
+ Blokced 阻塞状态  进程在执行IO等非CPU操作

![image-20200605141138613](https://tuchuansun.oss-cn-hangzhou.aliyuncs.com/image-20200605141138613.png)

## 进程的系统API

### fork()

fork()操作用来创建一个新的进程

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/wait.h>

int main ( int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
    } else { // parent goes down this path (main)
        int rc_wait = wait(NULL);
        printf("hello, I am parent of %d (rc_wait:%d) (pid:%d)\n",
               rc, rc_wait, (int) getpid());
    }
    return 0;
}
```

语句在调用` rc = fork` 后会返回两次,两个进程的代码一样,将要执行的代码都是 if(rc < 0),但是父子进程的rc值是不一样的,在父进程中返回值是子进程的PID,而在子进程中返回是0,如果fork失败则会返回负数.

### wait()

一般用于父线程中等待回收子进程的资源

当一个进程正常或者异常终止时,OS内核回向该进程的父进程发送一个信号

对于这种现象,父进程是默认忽略的.而调用wait()方法后则会进入判断,如果有子进程终止则立马返回

所以上述的代码返回一定是:

```shell
hello world (pid:29266)
hello, I am child (pid:29267)
hello, I am parent of 29267 (rc_wait:29267) (pid:29266)
```

### exec()

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<sys/wait.h >
int main ( int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
        char *myargs[3];
        myargs[0] = strdup("wc"); // program: "wc" (word count)
        myargs[1] = strdup("p3.c"); // argument: file to count
        myargs[2] = NULL; // marks end of array
        execvp(myargs[0], myargs); // runs word count
        printf("this shouldn’t print out");
    } else { // parent goes down this path (main)
        int rc_wait = wait(NULL);
        printf("hello, I am parent of %d (rc_wait:%d) (pid:%d)\n",
               rc, rc_wait, (int) getpid());
    }
    return 0;
}
```

exec()可以在进程中调用另一个程序，在上述代码中通过execvo调用了wc命令，计算了p3.c的代码行数

```
hello world (pid:29383)
hello, I am child (pid:29384)
29 107 1030 p3.c
hello, I am parent of 29384 (rc_wait:29384) (pid:29383)
```

​	运行excec()时，首先重新初始化堆栈和一些其他的内存空间，接着OS开始通过给定的参数来运行。他并不会创建一个新的进程，而是将当前的进程来替代。当exce()执行成功后会直接返回进程关闭。

### 三个命令的协同使用



